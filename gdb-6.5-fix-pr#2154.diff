 - this patch fixes bugs in gdb-6.5 (bug report #2154; this patch
   is the attachment to 2154)

 - apply this patch PRIOR to  'gdb-6.5-ssrl-20060811.diff'

*** gdb-6.5/gdb/remote.c.orig	2006-05-05 13:08:45.000000000 -0700
--- gdb-6.5/gdb/remote.c	2006-08-09 19:51:17.000000000 -0700
***************
*** 927,932 ****
--- 927,933 ----
      xsnprintf (&buf[2], rs->remote_packet_size - 2, "%x", th);
    putpkt (buf);
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
    if (gen)
      general_thread = th;
    else
***************
*** 948,953 ****
--- 949,955 ----
      xsnprintf (buf, rs->remote_packet_size, "T%08x", tid);
    putpkt (buf);
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
    return (buf[0] == 'O' && buf[1] == 'K');
  }
  
***************
*** 1452,1457 ****
--- 1454,1460 ----
    pack_threadinfo_request (threadinfo_pkt, fieldset, threadid);
    putpkt (threadinfo_pkt);
    getpkt (&rs->buf, &rs->buf_size, 0);
+   threadinfo_pkt = rs->buf;
    result = remote_unpack_thread_info_response (threadinfo_pkt + 2,
  					       threadid, info);
    return result;
***************
*** 1518,1523 ****
--- 1521,1527 ----
    pack_threadlist_request (rs->buf, startflag, result_limit, nextthread);
    putpkt (rs->buf);
    getpkt (&rs->buf, &rs->buf_size, 0);
+   threadlist_packet = rs->buf;
  
    *result_count =
      parse_threadlist_response (rs->buf + 2, result_limit, &echo_nextthread,
***************
*** 1629,1634 ****
--- 1633,1639 ----
  
    putpkt ("qC");
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
    if (buf[0] == 'Q' && buf[1] == 'C')
      /* Use strtoul here, so we'll correctly parse values whose highest
         bit is set.  The protocol carries them as a simple series of
***************
*** 1673,1680 ****
    if (use_threadinfo_query)
      {
        putpkt ("qfThreadInfo");
-       bufp = rs->buf;
        getpkt (&rs->buf, &rs->buf_size, 0);
        if (bufp[0] != '\0')		/* q packet recognized */
  	{
  	  while (*bufp++ == 'm')	/* reply contains one or more TID */
--- 1678,1685 ----
    if (use_threadinfo_query)
      {
        putpkt ("qfThreadInfo");
        getpkt (&rs->buf, &rs->buf_size, 0);
+       bufp = rs->buf;
        if (bufp[0] != '\0')		/* q packet recognized */
  	{
  	  while (*bufp++ == 'm')	/* reply contains one or more TID */
***************
*** 1693,1700 ****
  		}
  	      while (*bufp++ == ',');	/* comma-separated list */
  	      putpkt ("qsThreadInfo");
- 	      bufp = rs->buf;
  	      getpkt (&rs->buf, &rs->buf_size, 0);
  	    }
  	  return;	/* done */
  	}
--- 1698,1705 ----
  		}
  	      while (*bufp++ == ',');	/* comma-separated list */
  	      putpkt ("qsThreadInfo");
  	      getpkt (&rs->buf, &rs->buf_size, 0);
+ 	      bufp = rs->buf;
  	    }
  	  return;	/* done */
  	}
***************
*** 1738,1743 ****
--- 1743,1749 ----
  		 PIDGET (tp->ptid));
        putpkt (bufp);
        getpkt (&rs->buf, &rs->buf_size, 0);
+       bufp = rs->buf;
        if (bufp[0] != 0)
  	{
  	  n = min (strlen (bufp) / 2, sizeof (display_buf));
***************
*** 1819,1824 ****
--- 1825,1831 ----
  
    putpkt ("qOffsets");
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
  
    if (buf[0] == '\000')
      return;			/* Return silently.  Stub doesn't support
***************
*** 1981,1992 ****
       because we need both at the same time.  */
    msg = alloca (rs->remote_packet_size);
  
-   reply = rs->buf;
- 
    /* Invite target to request symbol lookups.  */
  
    putpkt ("qSymbol::");
    getpkt (&rs->buf, &rs->buf_size, 0);
    packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSymbol]);
  
    while (strncmp (reply, "qSymbol:", 8) == 0)
--- 1988,1998 ----
       because we need both at the same time.  */
    msg = alloca (rs->remote_packet_size);
  
    /* Invite target to request symbol lookups.  */
  
    putpkt ("qSymbol::");
    getpkt (&rs->buf, &rs->buf_size, 0);
+   reply = rs->buf;
    packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSymbol]);
  
    while (strncmp (reply, "qSymbol:", 8) == 0)
***************
*** 2003,2008 ****
--- 2009,2015 ----
  		   &reply[8]);
        putpkt (msg);
        getpkt (&rs->buf, &rs->buf_size, 0);
+       reply = rs->buf;
      }
  }
  
***************
*** 2274,2279 ****
--- 2281,2287 ----
    strcpy (buf, "vCont?");
    putpkt (buf);
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
  
    /* Make sure that the features we assume are supported.  */
    if (strncmp (buf, "vCont", 5) == 0)
***************
*** 2681,2686 ****
--- 2689,2695 ----
  
        ofunc = signal (SIGINT, remote_interrupt);
        getpkt (&rs->buf, &rs->buf_size, 1);
+       buf = rs->buf;
        signal (SIGINT, ofunc);
  
        /* This is a hook for when we need to do something (perhaps the
***************
*** 2877,2882 ****
--- 2886,2892 ----
           However, before we do that we need to ensure that the caller
           knows how to take the target into/out of async mode.  */
        getpkt (&rs->buf, &rs->buf_size, wait_forever_enabled_p);
+       buf = rs->buf;
        if (!target_is_async_p ())
  	signal (SIGINT, ofunc);
  
***************
*** 3171,3176 ****
--- 3181,3187 ----
  	fprintf_unfiltered (gdb_stdlog,
  			    "Bad register packet; fetching a new packet\n");
        getpkt (&rs->buf, &rs->buf_size, 0);
+       buf = rs->buf;
      }
  
    /* Reply describes registers byte by byte, each byte encoded as two
***************
*** 3443,3448 ****
--- 3454,3460 ----
  
  	putpkt_binary (buf, (int) (p - buf));
  	getpkt (&rs->buf, &rs->buf_size, 0);
+ 	buf = rs->buf;
  
  	if (buf[0] == '\0')
  	  {
***************
*** 3600,3605 ****
--- 3612,3618 ----
  
    putpkt_binary (buf, (int) (p - buf));
    getpkt (&rs->buf, &rs->buf_size, 0);
+   buf = rs->buf;
  
    if (buf[0] == 'E')
      {
***************
*** 3665,3670 ****
--- 3678,3684 ----
  
        putpkt (buf);
        getpkt (&rs->buf, &rs->buf_size, 0);
+       buf = rs->buf;
  
        if (buf[0] == 'E'
  	  && isxdigit (buf[1]) && isxdigit (buf[2])
***************
*** 4971,4976 ****
--- 4985,4991 ----
        /* XXX - see also tracepoint.c:remote_get_noisy_reply().  */
        buf[0] = '\0';
        getpkt (&rs->buf, &rs->buf_size, 0);
+       buf = rs->buf;
        if (buf[0] == '\0')
  	error (_("Target does not support this command."));
        if (buf[0] == 'O' && buf[1] != 'K')
